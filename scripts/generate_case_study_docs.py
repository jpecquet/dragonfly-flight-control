#!/usr/bin/env python3
"""Generate case-study markdown snippets from data/case_studies/*/case.json."""

from __future__ import annotations

import argparse
import json
import math
from pathlib import Path
from typing import Any

try:
    from case_data import select_experiment
except ModuleNotFoundError:
    from scripts.case_data import select_experiment


REPO_ROOT = Path(__file__).resolve().parents[1]
CASE_ROOT = REPO_ROOT / "data" / "case_studies"
OUT_DIR = REPO_ROOT / "docs" / "case_studies" / "generated"


def _fmt_number(value: float) -> str:
    v = float(value)
    if v == 0.0:
        return "0"
    mag = abs(v)
    if mag >= 1.0e4 or mag < 1.0e-3:
        return f"{v:.3e}"
    return f"{v:.6g}"


def _fmt_row(value: float, unit: str) -> str:
    return f"`{_fmt_number(value)} {unit}`"


def _load_case(case_id: str) -> dict[str, Any]:
    path = CASE_ROOT / case_id / "case.json"
    return json.loads(path.read_text(encoding="utf-8"))


def _term_cell(terms: list[dict[str, Any]]) -> str:
    if not terms:
        return "`-`"
    rendered = []
    for term in terms:
        rendered.append(
            f"k={int(term['harmonic'])}: A={_fmt_number(float(term['amplitude_deg']))}, "
            f"phase={_fmt_number(float(term['phase_deg']))} deg"
        )
    return "<br>".join(rendered)


def _build_fourier_table(case: dict[str, Any]) -> str:
    kinematics = case["kinematics"]
    convention = case["convention"]
    source_names = convention["source_angle_names"]

    lines = [
        "| Wing | Series | mean (deg) | Fourier terms |",
        "|---|---|---:|---|",
    ]
    for wing in ("fore", "hind"):
        wing_payload = kinematics["angles"][wing]
        for angle in ("gamma", "phi", "psi"):
            series = wing_payload[angle]
            label = source_names.get(angle, angle)
            lines.append(
                "| "
                f"{wing} | {label} | {_fmt_number(float(series['mean_deg']))} | {_term_cell(series['terms'])} |"
            )
    return "\n".join(lines)


def _sort_experiment_ids(experiments: dict[str, Any]) -> list[str]:
    return sorted(experiments.keys(), key=lambda s: int(s) if str(s).isdigit() else str(s))


def _flight_condition_line(case: dict[str, Any]) -> str:
    for output in case.get("output_references", []):
        if output.get("kind") != "flight_condition":
            continue
        return (
            f"speed `{_fmt_number(float(output['speed_m_s']))} m/s`, "
            f"direction `{_fmt_number(float(output['direction_deg']))} deg`"
        )
    return "not specified"


def _generate_azuma_multi_experiment_description(case_id: str, case: dict[str, Any]) -> str:
    specimen = case["specimen"]
    sim_defaults = case["simulation_defaults"]
    experiments = case["experiments"]
    coning = sim_defaults.get("coning_angles_deg")

    lines = [
        "<!-- Auto-generated by scripts/generate_case_study_docs.py; do not edit by hand. -->",
        f"Source: `data/case_studies/{case_id}/case.json`.",
        "",
        "### Dragonfly Specimen",
        "",
        "| Parameter | Value |",
        "|---|---|",
        f"| Body length $L$ | {_fmt_row(float(specimen['body_length_m']), 'm')} |",
        f"| Body mass $m$ | {_fmt_row(float(specimen['body_mass_kg']), 'kg')} |",
        f"| Forewing span $R_{'{fw}'}$ | {_fmt_row(float(specimen['fore_span_m']), 'm')} |",
        f"| Forewing area $S_{'{fw}'}$ | {_fmt_row(float(specimen['fore_area_m2']), 'm^2')} |",
        f"| Hindwing span $R_{'{hw}'}$ | {_fmt_row(float(specimen['hind_span_m']), 'm')} |",
        f"| Hindwing area $S_{'{hw}'}$ | {_fmt_row(float(specimen['hind_area_m2']), 'm^2')} |",
        "",
    ]
    if coning is not None:
        lines.extend(
            [
                "Coning angles (shared across experiments):",
                f"- Fore: `{_fmt_number(float(coning['fore']))} deg`",
                f"- Hind: `{_fmt_number(float(coning['hind']))} deg`",
                "",
            ]
        )

    lines.extend(
        [
            "### Experiments Summary",
            "",
            "| Experiment | Dragonfly | Frequency (Hz) | Fore gamma (deg) | Hind gamma (deg) | Reference flight condition |",
            "|---|---|---:|---:|---:|---|",
        ]
    )
    for exp_id in _sort_experiment_ids(experiments):
        exp_case = select_experiment(case, experiment_id=exp_id)
        dragonfly = exp_case["selected_experiment"].get("dragonfly") or "-"
        freq_hz = float(exp_case["simulation_defaults"]["frequency_hz"])
        fore_gamma = float(exp_case["kinematics"]["angles"]["fore"]["gamma"]["mean_deg"])
        hind_gamma = float(exp_case["kinematics"]["angles"]["hind"]["gamma"]["mean_deg"])
        lines.append(
            "| "
            f"{exp_id} | {dragonfly} | {_fmt_number(freq_hz)} | {_fmt_number(fore_gamma)} | "
            f"{_fmt_number(hind_gamma)} | {_flight_condition_line(exp_case)} |"
        )

    lines.append("")
    for exp_id in _sort_experiment_ids(experiments):
        exp_case = select_experiment(case, experiment_id=exp_id)
        selected = exp_case["selected_experiment"]
        dragonfly = selected.get("dragonfly") or "?"
        lines.extend(
            [
                f"### Experiment {exp_id} (Dragonfly {dragonfly})",
                "",
                f"Flapping frequency: `{_fmt_number(float(exp_case['simulation_defaults']['frequency_hz']))} Hz`",
                "",
                "Paper-convention Fourier data (degrees):",
                "",
                _build_fourier_table(exp_case),
                "",
                "Experimental output reference:",
                f"- `body_speed_and_direction`: {_flight_condition_line(exp_case)}",
                "",
            ]
        )
    return "\n".join(lines)


def _generate_azuma_description(case_id: str) -> str:
    case = _load_case(case_id)
    experiments = case.get("experiments")
    if isinstance(experiments, dict) and experiments:
        return _generate_azuma_multi_experiment_description(case_id, case)

    specimen = case["specimen"]
    sim_defaults = case["simulation_defaults"]
    outputs = case["output_references"]

    coning = sim_defaults.get("coning_angles_deg")

    lines = [
        "<!-- Auto-generated by scripts/generate_case_study_docs.py; do not edit by hand. -->",
        f"Source: `data/case_studies/{case_id}/case.json`.",
        "",
        "### Dragonfly Specimen",
        "",
        "| Parameter | Value |",
        "|---|---|",
        f"| Body length $L$ | {_fmt_row(float(specimen['body_length_m']), 'm')} |",
        f"| Body mass $m$ | {_fmt_row(float(specimen['body_mass_kg']), 'kg')} |",
        f"| Forewing span $R_{'{fw}'}$ | {_fmt_row(float(specimen['fore_span_m']), 'm')} |",
        f"| Forewing area $S_{'{fw}'}$ | {_fmt_row(float(specimen['fore_area_m2']), 'm^2')} |",
        f"| Hindwing span $R_{'{hw}'}$ | {_fmt_row(float(specimen['hind_span_m']), 'm')} |",
        f"| Hindwing area $S_{'{hw}'}$ | {_fmt_row(float(specimen['hind_area_m2']), 'm^2')} |",
        "",
        "### Wing Kinematics",
        "",
        f"Flapping frequency: `{_fmt_number(float(sim_defaults['frequency_hz']))} Hz`",
        "",
    ]
    if coning is not None:
        lines.extend(
            [
                "Coning angles:",
                f"- Fore: `{_fmt_number(float(coning['fore']))} deg`",
                f"- Hind: `{_fmt_number(float(coning['hind']))} deg`",
                "",
            ]
        )

    lines.extend(
        [
            "Paper-convention Fourier data (degrees):",
            "",
            _build_fourier_table(case),
            "",
            "### Experimental Output References",
            "",
        ]
    )

    for output in outputs:
        if output.get("kind") != "flight_condition":
            continue
        lines.extend(
            [
                f"- `{output['name']}`: speed `{_fmt_number(float(output['speed_m_s']))} m/s`, "
                f"direction `{_fmt_number(float(output['direction_deg']))} deg`",
            ]
        )
        if output.get("direction_definition"):
            lines.append(f"  - Definition: `{output['direction_definition']}`")

    lines.append("")
    return "\n".join(lines)


def _compute_wang_key_parameters(case: dict[str, Any]) -> dict[str, float]:
    specimen = case["specimen"]
    defaults = case["simulation_defaults"]

    body_length_m = float(specimen["body_length_mm"]) * 1.0e-3
    wing_length_m = float(specimen["wing_length_mm"]) * 1.0e-3
    wing_area_m2 = float(specimen["wing_area_mm2"]) * 1.0e-6
    body_mass_kg = float(specimen["body_mass_mg"]) * 1.0e-6
    frequency_hz = float(defaults["frequency_hz"])
    rho = float(defaults["rho_air_kg_m3"])
    gravity = float(defaults["gravity_m_s2"])

    tau = math.sqrt(body_length_m / gravity)
    omega = 2.0 * math.pi * frequency_hz * tau
    lb0 = wing_length_m / body_length_m
    mu0 = rho * wing_area_m2 * wing_length_m / body_mass_kg

    n_wingbeats = int(defaults["n_wingbeats"])
    harmonics_per_wingbeat = int(defaults["harmonics_per_wingbeat"])

    return {
        "omega": omega,
        "lb0": lb0,
        "mu0": mu0,
        "harmonics_per_wingbeat": float(harmonics_per_wingbeat),
        "fourier_components": float(harmonics_per_wingbeat * n_wingbeats),
        "n_wingbeats": float(n_wingbeats),
        "steps_per_wingbeat": float(int(defaults["steps_per_wingbeat"])),
    }


def _generate_wang_key_parameters() -> str:
    case_id = "wang2007"
    case = _load_case(case_id)
    params = _compute_wang_key_parameters(case)
    timeseries = case["kinematics"]["timeseries"]

    lines = [
        "<!-- Auto-generated by scripts/generate_case_study_docs.py; do not edit by hand. -->",
        f"Source: `data/case_studies/{case_id}/case.json`.",
        "",
        f"- `omega`: `{params['omega']:.12f}`",
        f"- `lb0`: `{params['lb0']:.12f}`",
        f"- `mu0`: `{params['mu0']:.12f}`",
        f"- `harmonics_per_wingbeat`: `{int(params['harmonics_per_wingbeat'])}`",
        f"- `fourier_components`: `{int(params['fourier_components'])}`",
        f"- `n_wingbeats`: `{int(params['n_wingbeats'])}`",
        f"- `steps_per_wingbeat`: `{int(params['steps_per_wingbeat'])}`",
        "",
        "Input timeseries source:",
        f"- `csv`: `{timeseries['csv_path']}`",
    ]

    return "\n".join(lines) + "\n"


def _write(path: Path, text: str, *, check: bool) -> bool:
    if path.exists():
        existing = path.read_text(encoding="utf-8")
    else:
        existing = None

    if existing == text:
        print(f"[ok] {path.relative_to(REPO_ROOT)}")
        return True

    if check:
        print(f"[stale] {path.relative_to(REPO_ROOT)}")
        return False

    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(text, encoding="utf-8")
    print(f"[write] {path.relative_to(REPO_ROOT)}")
    return True


def main() -> int:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--check",
        action="store_true",
        help="Only check whether generated files are up to date.",
    )
    args = parser.parse_args()

    outputs = {
        OUT_DIR / "azuma1985_description.md": _generate_azuma_description("azuma1985"),
        OUT_DIR / "azuma1988_description.md": _generate_azuma_description("azuma1988"),
        OUT_DIR / "wang2007_key_parameters.md": _generate_wang_key_parameters(),
    }

    ok = True
    for path, text in outputs.items():
        if not _write(path, text, check=args.check):
            ok = False

    if args.check and not ok:
        print("Case-study generated docs are out of date. Run: python scripts/generate_case_study_docs.py")
        return 1
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
